*****************
* HIGH priority *
*****************

- add read of compressed attributes

*******************
* MEDIUM priority *
*******************

- create API reference book template (cf. linux kernel)
- enable automatic creation of API reference

- add write of compressed attributes

- write attribute resize function (see mkntfs) and implement ntfs_truncate*

- write ntfs_cluster(s)_{allocate,free} (see ntfs 2.4 driver in CVS)

- extend ntfs_attr_pwrite to cope with extending the attribute size and with
  instantiating holes

- write ntfs_mft_record_{allocate,free} (see ntfs 2.4 driver in CVS)

- write ntfs_attr_{rm,create,add}()

- write ntfs_index_{rm_from,add_to,create,rm}()

- write ntfs_file_name_{add,rm}_from_mft_record() or _from_ntfs_inode(?)

- write ntfs_file_unlink()

- write ntfs_file_create()

- write API for conventional high level file access.

- implement loads of utilities a-la ntcp, ntrm, ntcreat, ntdir, etc...

- implement a ntfs shell where can use the above much faster with caching,
  probably extending the library in the process

- extend attrib API with ntfs_rl_pread()

****************
* LOW priority *
****************

- Do we attach attributes (ntfs_attr) to the corresponding ntfs_inode? Now we
  just atach the inode to the attribute and expect the user to not shoot
  themselves in the foot.

- add read/set of various file attributes/flags to library

- add ACL read/write support to library

- add MS BackupAPI to library

- add volume resizing support to library

- add defrag API to library

- write utilities for all of the above

